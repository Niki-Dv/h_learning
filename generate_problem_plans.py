# imports
import random
import subprocess
import pandas as pd
import numpy as np
import os
import augment_problem_data
import time
import h_config

config = h_config.config().get_config()


###############################################################################################
def GenerateProblemsPlans(NProbDF):
    """
    Activate external problems generator code and planner code,
    and add both problem and plan to the problem data frame given
    :param NProbDF: data frame with all the data for each problem generation
    :return: the data frame given with added data about problem in pddl
            and the plan for problem (if exists)
    """
    config = h_config.config().get_config()
    processes = []
    # create problem using the parameters in data frame
    for i in range(0, NProbDF.shape[0]):
        NProbDF.at[i, "id"] = i
        NProbDF.at[i, "from_id"] = i
        gen_val_list = NProbDF.iloc[i].to_list()[:-4]
        cmd_val_list = [np.array2string(val) for val in gen_val_list]
        cmd_val_list.insert(0, config.generator_path)
        cmd_line = " ".join(cmd_val_list)
        prob_out_path = os.path.join(config.problems_dir, "prob_" + i.__str__() + ".pddl")
        with open(prob_out_path, "w") as fd:
            ProblemDescription = subprocess.Popen(cmd_line, stdout=fd, stderr=subprocess.PIPE, shell=True)
            processes.append(ProblemDescription)
        NProbDF.at[i, "problem"] = prob_out_path

    for process in processes:
        process.wait()

    processes = []
    # for each problem, create plan using planner
    for i in range(0, NProbDF.shape[0]):
        plan_out_path = os.path.join(config.plans_dir, "plan_" + i.__str__() + ".txt")
        cmd_line_args = ['python', config.planner_path, "--plan-file", plan_out_path, config.domain_pddl_path,
                         NProbDF.at[i, "problem"],
                         "--search \"astar(lmcut())\""]
        cmd_line = " ".join(cmd_line_args)
        sub_res = subprocess.Popen(cmd_line, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        processes.append(sub_res)
        NProbDF.at[i, "plan"] = plan_out_path

    for process in processes:
        process.wait()


###############################################################################################
def GenProblemsDataFrame():
    """
    Function Description: Generates N problems of a certain domain using a given generator path and a list of its
                     needed descriptor titles and their ranges
    Inputs: 1- N (integer) states the number of problems to generate 2 - Generator Path (string)
        3- ProbDescriptorsInfo (list of lists) - each descriptor list includes the title of each descriptor (string)
        and the min and max values possible for that descriptor
    Output: 1- NProbDF (Pandas DataFrame) - The columns of the dataframe are the problem descriptors and the
           and the final column is the problem as generated,and each row represents a problem generated
    """

    DescriptorTitles = []
    for i in range(len(config.ProbDescriptorsInfo)):
        DescriptorTitles.append(config.ProbDescriptorsInfo[i][0])
    DescriptorTitles.append("problem")
    DescriptorTitles.append("plan")
    DescriptorTitles.append("id")
    DescriptorTitles.append("from_id")
    list_generated_descriptor = []
    for i in range(config.N):
        ProbDescriptorVals = []
        for j in range(len(config.ProbDescriptorsInfo)):
            descr_value = random.randint(config.ProbDescriptorsInfo[j][1], config.ProbDescriptorsInfo[j][2])
            ProbDescriptorVals.append(descr_value)
            if j == (len(config.ProbDescriptorsInfo) - 1):
                ProbDescriptorVals += ["", "", i, "parent_problem"]
                list_generated_descriptor.append(ProbDescriptorVals)

    NProbDF = pd.DataFrame(list_generated_descriptor, columns=DescriptorTitles)
    GenerateProblemsPlans(NProbDF)
    return NProbDF


##############################################################################################
def ExtractPlan(NProbDF):
    """
    Extracts the plan itself from all the plan data that is created by planner
    and overrides the original plan generated by planner
    """
    import re
    time.sleep(1)
    plan_lengths = []
    correct_plans = []
    for index, row in NProbDF.iterrows():
        needed_data = []
        curr_plan_path = row["plan"]
        plan_exist = False

        if not os.path.exists(curr_plan_path):
            print("no plan for: " + str(index))
            continue

        with open(curr_plan_path, 'r') as plan_f:
            for cnt, line in enumerate(plan_f):
                if re.search("cost = ", line, re.IGNORECASE):
                    plan_length = re.findall("[0-9]+", line)
                    plan_lengths.append(plan_length[0])
                    plan_exist = True
                    break

                needed_data.append(line)

        if plan_exist:
            correct_plans.append(index)
            with open(curr_plan_path, "w") as fh:
                for plan_step in needed_data:
                    fh.write(plan_step)

    corrupt_plans = [i for i in range(config.N)]
    for correct_plan in correct_plans:
        corrupt_plans.remove(correct_plan)

    NProbDF = NProbDF.drop(corrupt_plans)
    NProbDF["plan length"] = plan_lengths

    return NProbDF


##############################################################################################
def main():
    NProbDF = GenProblemsDataFrame()
    NProbDF = ExtractPlan(NProbDF)
    # todo: check how the new_problems_path param is chosen - probably need to generate it inside the function
    NProbDF = augment_problem_data.main(config.domain_pddl_path, NProbDF, config.subproblems_dir)
    return NProbDF


if __name__ == '__main__':
    main()
