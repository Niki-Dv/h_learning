# imports
import random
import subprocess
import pandas as pd
import numpy as np
from datetime import datetime
import os
import augment_problem_data
import time
import h_config
from scipy.fftpack import fft2
import torch
import logging

logger = logging.getLogger()

config = h_config.config().get_config()


###############################################################################################
def GenerateProblemsPlans(NProbDF):
    """
    Activate external problems generator code and planner code,
    and add both problem and plan to the problem data frame given
    :param NProbDF: data frame with all the data for each problem generation
    :return: the data frame given with added data about problem in pddl
            and the plan for problem (if exists)
    """
    config = h_config.config.get_config()
    processes = []
    # create problem using the parameters in data frame
    for i in range(0, NProbDF.shape[0]):
        NProbDF.at[i, "id"] = i
        NProbDF.at[i, "from_id"] = i
        gen_val_list = NProbDF.iloc[i].to_list()[:-4]
        cmd_val_list = [np.array2string(val) for val in gen_val_list]
        cmd_val_list.insert(0, config.generator_path)
        cmd_line = " ".join(cmd_val_list)
        prob_out_path = os.path.join(config.problems_dir, "prob_" + i.__str__() + ".pddl")
        with open(prob_out_path, "w") as fd:
            ProblemDescription = subprocess.Popen(cmd_line, stdout=fd, stderr=subprocess.PIPE, shell=True)
            processes.append(ProblemDescription)
        NProbDF.at[i, "problem"] = prob_out_path

    for process in processes:
        process.wait()

    logger.debug('finished creating problems, startingg creating plans')
    failed_problem = [] # todo: understand if no plan means impsoible
    # for each problem, create plan using planner
    for i in range(0, NProbDF.shape[0]):
        plan_out_path = os.path.join(config.plans_dir, "plan_" + i.__str__())
        cmd_line_args = ["exec", config.python_path, config.planner_path, "--plan-file", plan_out_path, config.domain_pddl_path,
                         NProbDF.at[i, "problem"], config.planner_search_flag]
        cmd_line = " ".join(cmd_line_args)
        sub_proc = subprocess.Popen(cmd_line, stdout=None, stderr=None, shell=True)
        try:
            sub_proc.wait(timeout=config.plan_finding_timeout)
        except subprocess.TimeoutExpired:
            sub_proc.kill()
            logger.warning("reached to time out for finding plan for problem {} , continuing".format(i))
            NProbDF.at[i, "plan"] = None
            continue

        logger.debug("Found plan for problem {}".format(i))
        NProbDF.at[i, "plan"] = plan_out_path

    return NProbDF

###############################################################################################
def GenProblemsPlans():
    """
    Function Description: Generates N problems of a certain domain using a given generator path and a list of its
                     needed descriptor titles and their ranges

    Output: 1- NProbDF (Pandas DataFrame) - The columns of the dataframe are the problem descriptors and the
           and the final column is the problem as generated,and each row represents a problem generated
    """

    DescriptorTitles = []
    for i in range(len(config.ProbDescriptorsInfo[0])):
        DescriptorTitles.append(config.ProbDescriptorsInfo[0][i][0])
    DescriptorTitles.append("problem")
    DescriptorTitles.append("plan")
    DescriptorTitles.append("id")
    DescriptorTitles.append("from_id")
    list_generated_descriptor = []

    for i in range(config.N):
        curr_diff_lvl = 0 # todo: change back
        ProbDescriptorVals = []
        for j in range(len(config.ProbDescriptorsInfo[0])):
            descr_value = random.randint(config.ProbDescriptorsInfo[curr_diff_lvl][j][1],
                                         config.ProbDescriptorsInfo[curr_diff_lvl][j][2])
            ProbDescriptorVals.append(descr_value)
            if j == (len(config.ProbDescriptorsInfo[0]) - 1):
                ProbDescriptorVals += ["", "", i, "parent_problem"]
                list_generated_descriptor.append(ProbDescriptorVals)

    NProbDF = pd.DataFrame(list_generated_descriptor, columns=DescriptorTitles)
    GenerateProblemsPlans(NProbDF)
    return NProbDF


##############################################################################################
def ExtractPlans(NProbDF):
    """
    Extracts the plan itself from all the plan data that is created by planner
    and overrides the original plan generated by planner
    """
    import re
    time.sleep(1)
    plan_lengths = []
    correct_plans = []
    for index, row in NProbDF.iterrows():
        needed_data = []
        curr_plan_path = row["plan"]
        plan_exist = False

        if not os.path.exists(curr_plan_path):
            print("no plan for: " + str(index))
            continue

        with open(curr_plan_path, 'r') as plan_f:
            for cnt, line in enumerate(plan_f):
                if re.search("cost = ", line, re.IGNORECASE):
                    plan_length = re.findall("[0-9]+", line)
                    plan_lengths.append(plan_length[0])
                    plan_exist = True
                    break

                needed_data.append(line)

        if plan_exist:
            correct_plans.append(index)
            with open(curr_plan_path, "w") as fh:
                for plan_step in needed_data:
                    fh.write(plan_step)

    corrupt_plans = [i for i in range(NProbDF.shape[0])]
    for correct_plan in correct_plans:
        corrupt_plans.remove(correct_plan)

    NProbDF = NProbDF.drop(corrupt_plans)
    NProbDF["plan length"] = plan_lengths

    return NProbDF

##############################################################################################
def create_problem_images(df, images_dir_path, python_path, domain_pddl_path, time_limit):
    df['image'] = None
    non_image_problems_indexes = []
    for i in range(0, df.shape[0]):

        image_path = os.path.join(images_dir_path, "prob_img_" + str(i) + ".png")
        cmd_line_args = ['exec', python_path, config.image_creater_path, "--image-from-lifted-task ",
                         domain_pddl_path, df.at[i, "problem"], image_path]
        cmd_line = " ".join(cmd_line_args)
        logger.debug("Creating image number: {}".format(i))
        sub_proc = subprocess.Popen(cmd_line, shell=True)
        try:
            sub_proc.wait(timeout=time_limit)
        except subprocess.TimeoutExpired:
            sub_proc.kill()
            logger.warning("reached to time out for finding image for problem {} , continuing".format(i))
            non_image_problems_indexes.append(i)
            continue

        df.at[i, "image"] = image_path

    logger.error("Couldn't create image for problems at indexes: {}".format(non_image_problems_indexes))

##############################################################################################
def fourier_transform(df, image):
    # fourier transform
    transformed_image = fft2(image)
    # normalize by the top left pixel
    #transformed_image = transformed_image / transformed_image[0, 0]
    # split into the real and imaginary parts of the ft
    real_transformed_image = np.real(transformed_image)
    img_transformed_image = np.imag(transformed_image)
    #
    image = np.dstack((real_transformed_image, img_transformed_image))
    image = np.swapaxes(image, 0, -1) # todo: check wihtout

    # move to torch
    image = torch.from_numpy(image)
    #image = image.to(device)
    # image.unsqueeze_(0)

    # image = torch.from_numpy(image)
    # image = image.to(device)
    # image.unsqueeze_(0)

    return image


##############################################################################################
def add_date_to_paths(config):
    """
    adds time and date signature to directories names
    """
    # datetime object containing current date and time
    now = datetime.now()

    # dd/mm/YY H:M:S
    dt_string = now.strftime("_%d_%m_%Y_%H_%M_%S")
    config.problems_dir += dt_string
    config.subproblems_dir += dt_string
    config.plans_dir += dt_string
    config.img_dir += dt_string
    config.csv_path += dt_string + ".csv"


###############################################################################################
def create_dirs(paths_list):
    for path in paths_list:
        try:
            os.mkdir(path)
        except OSError:
            print("Creation of the directory %s failed" % path)
            exit(1)
###############################################################################################
def save_info_df_as_csv(info_df):
    info_df.to_csv(config.csv_path)

##############################################################################################
def delete_unsolved_problems(NProbDF):
    indexes_of_unsolved = []
    for i in range(0, NProbDF.shape[0]):
        if NProbDF.iloc[i]['plan'] is None:
            indexes_of_unsolved.append(i)

    return NProbDF.drop(indexes_of_unsolved)

##############################################################################################
def main():
    h_config.define_logger(logger, config.logger_path)
    logger.info("Started run of script")
    add_date_to_paths(config)
    create_dirs([config.plans_dir, config.problems_dir, config.subproblems_dir, config.img_dir])
    logger.debug("Finished preparing directories and paths, starting generating data")

    NProbDF = GenProblemsPlans()
    logger.debug("Finished creating problems and plans")

    NProbDF = delete_unsolved_problems(NProbDF)
    NProbDF.reset_index(drop=True, inplace=True)
    # save for case of interrupt
    save_info_df_as_csv(NProbDF)
    logger.debug("Deleted unsolved problems")

    NProbDF = ExtractPlans(NProbDF)
    logger.debug("Finished extracting plans in needed format")

    NProbDF = augment_problem_data.main(config.domain_pddl_path, NProbDF, config.subproblems_dir)
    logger.debug("Finished creating sub problems")
    save_info_df_as_csv(NProbDF)

    create_problem_images(NProbDF, config.img_dir, config.python_path, config.domain_pddl_path,
                          config.plan_finding_timeout)
    logger.debug("Finished creating images")
    save_info_df_as_csv(NProbDF)
    logger.debug("Finished data creation")
    
    return NProbDF


if __name__ == '__main__':
    main()
