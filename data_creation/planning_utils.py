# imports
import random
import subprocess
import pandas as pd
import numpy as np
import os, sys
import time
import logging


curr_dir_path = os.path.dirname(os.path.realpath(__file__))
package_path = os.path.join(curr_dir_path, '..')
if package_path in sys.path:
    sys.path.append(package_path)

from data_creation import regenrate_data, h_config

logger = logging.getLogger()

###############################################################################################
def GenerateProblems(NProbDF):
    """
    Create problems using external problem generator, add as rows
    """
    rows_to_delete = []
    NProbDF["problem"] = None
    config = h_config.config.get_config()
    processes = []
    # create problem using the parameters in data frame
    for i in range(0, NProbDF.shape[0]):
        NProbDF.at[i, "id"] = i
        NProbDF.at[i, "from_id"] = i
        cmd_val_list = NProbDF.iloc[i].to_list()[:6]
        cmd_val_list = [str(val) for val in cmd_val_list]
        cmd_val_list.insert(0, config.generator_path)
        cmd_line = " ".join(cmd_val_list)
        prob_out_path = os.path.join(config.problems_dir, "prob_" + i.__str__() + ".pddl")
        logger.debug("The cmd line is: {}".format(cmd_line))
        with open(prob_out_path, "w") as fd:
            proc = subprocess.Popen(cmd_line, stdout=fd, stderr=subprocess.PIPE, shell=True)
            proc.wait()

        if os.stat(prob_out_path).st_size == 0:
            rows_to_delete.append(i)
        else:
            NProbDF.at[i, "problem"] = prob_out_path

    NProbDF = NProbDF.drop(rows_to_delete)
    NProbDF.reset_index(drop=True, inplace=True)
    logger.debug('finished creating problems')

    return NProbDF

###############################################################################################
def SolveProblems(NProbDF, config):
    """
    solve problems using external planner, add as rows the solution
    """
    NProbDF["plan"] = None
    failed_problem = []
    # for each problem, create plan using planner
    for i in range(0, NProbDF.shape[0]):
        plan_out_path = os.path.join(config.plans_dir, "plan_" + i.__str__())
        cmd_line_args = ["exec", config.python_path, config.planner_path, "--plan-file", plan_out_path,
                         config.domain_pddl_path,
                         NProbDF.at[i, "problem"], config.planner_search_flag]
        cmd_line = " ".join(cmd_line_args)
        sub_proc = subprocess.Popen(cmd_line, stdout=None, stderr=None, shell=True)
        try:
            sub_proc.wait(timeout=config.plan_finding_timeout)
        except subprocess.TimeoutExpired:
            sub_proc.kill()
            logger.warning("reached to time out for finding plan for problem {} , continuing".format(i))
            NProbDF.at[i, "plan"] = None
            continue

        logger.debug("Found plan for problem {}".format(i))
        NProbDF.at[i, "plan"] = plan_out_path

    return NProbDF

###############################################################################################
def GenProblemsParams(config):
    """
    Function Description: Generates N problems of a certain domain using a given generator path and a list of its
                     needed descriptor titles and their ranges

    Output: 1- NProbDF (Pandas DataFrame) - The columns of the dataframe are the problem descriptors and the
           and the final column is the problem as generated,and each row represents a problem generated
    """

    DescriptorTitles = []
    for i in range(len(config.ProbDescriptors)):
        DescriptorTitles.append(config.ProbDescriptors[i])

    DescriptorTitles.append("id")
    DescriptorTitles.append("from_id")

    generated_descriptors_list = []
    generator_limits = [4, 4, 4, 4, 5]
    for i in range(config.N):
        ProbDescriptorVals = [i+1]
        for j in range(len(generator_limits)):
            descr_value = random.randint(1, generator_limits[j])
            ProbDescriptorVals.append(descr_value)

        # number of waypoints has to be greater than number of rovers
        if ProbDescriptorVals[2] < ProbDescriptorVals[1]:
            ProbDescriptorVals[2] = ProbDescriptorVals[1]

        ProbDescriptorVals += [i, "parent_problem"]
        generated_descriptors_list.append(ProbDescriptorVals)

    NProbDF = pd.DataFrame(generated_descriptors_list, columns=DescriptorTitles)
    return NProbDF

##############################################################################################
def ExtractPlans(NProbDF):
    """
    Extracts the plan itself from all the plan data that is created by planner
    and overrides the original plan generated by planner
    """
    import re
    time.sleep(1)
    plan_lengths = []
    correct_plans = []
    for index, row in NProbDF.iterrows():
        needed_data = []
        curr_plan_path = row["plan"]
        plan_exist = False

        if not os.path.exists(curr_plan_path):
            print("no plan for: " + str(index))
            continue

        with open(curr_plan_path, 'r') as plan_f:
            for cnt, line in enumerate(plan_f):
                if re.search("cost = ", line, re.IGNORECASE):
                    plan_length = re.findall("[0-9]+", line)
                    plan_lengths.append(plan_length[0])
                    plan_exist = True
                    break

                needed_data.append(line)

        if plan_exist:
            correct_plans.append(index)
            with open(curr_plan_path, "w") as fh:
                for plan_step in needed_data:
                    fh.write(plan_step)

    corrupt_plans = [i for i in range(NProbDF.shape[0])]
    for correct_plan in correct_plans:
        corrupt_plans.remove(correct_plan)

    NProbDF = NProbDF.drop(corrupt_plans)
    NProbDF["plan length"] = plan_lengths

    return NProbDF

##############################################################################################
def create_problem_images(df, images_dir_path, python_path, domain_pddl_path, config):
    time_limit = config.plan_finding_timeout
    df['image'] = None
    non_image_problems_indexes = []
    for i in range(0, df.shape[0]):

        image_path = os.path.join(images_dir_path, "prob_img_" + str(i) + ".png")
        path_of_problem_pddl = df.at[i, "problem"]
        logger.debug("creating image for problem: {}".format(path_of_problem_pddl))
        cmd_line_args = ['exec', python_path, config.image_creater_path, "--image-from-lifted-task",
                         domain_pddl_path, df.at[i, "problem"], image_path]
        cmd_line = " ".join(cmd_line_args)
        logger.debug("Creating image number: {}".format(i))
        sub_proc = subprocess.Popen(cmd_line, shell=True)

        try:
            sub_proc.wait(timeout=time_limit)
        except subprocess.TimeoutExpired:
            sub_proc.kill()
            logger.warning("reached to time out for finding image for problem {} , continuing".format(i))
            non_image_problems_indexes.append(i)
            continue

        df.at[i, "image"] = image_path

    if len(non_image_problems_indexes) !=0:
        logger.error("Couldn't create image for problems at indexes: {}".format(non_image_problems_indexes))

##############################################################################################
def delete_unsolved_problems(NProbDF):
    indexes_of_unsolved = []
    for i in range(0, NProbDF.shape[0]):
        if NProbDF.iloc[i]['plan'] is None:
            indexes_of_unsolved.append(i)
            logger.debug("Problem {} is deleted".format(i))

    return NProbDF.drop(indexes_of_unsolved)

##############################################################################################
def add_subproblems_to_df(df, subproblem_paths_list, df_parent_row):
    """
    adds given sub problems paths to problems data frame
    :param subproblem_paths_list: paths list, with all the sub problems paths
    :param df_parent_row:
    :return:
    """
    prob_row = df_parent_row
    df_insert = pd.DataFrame([prob_row] * len(subproblem_paths_list), columns=df.columns).reset_index(drop=True)

    # stating that all rows that will be added to the df are of subproblems
    df_insert["id"] = "sub"

    sub_prob_index = 1
    for index, row in df_insert.iterrows():
        # assigning the subproblem path to each line
        df_insert.at[index, "problem"] = subproblem_paths_list[index]
        df_insert.at[index, "plan length"] = int(row["plan length"]) - sub_prob_index
        sub_prob_index += 1

    df = pd.concat([df, df_insert]).reset_index(drop=True)

    return df

##############################################################################################
def find_sub_problems(domain_file, NProbDF, sub_problems_path):
    """
    adds given sub problems paths to problems data frame
    :param sub_problems_path: directory path for sub problems
    """
    for index, row in NProbDF.iterrows():
        curr_prob_path = row["problem"]
        curr_plan_path = row["plan"]
        curr_prob_id = row["id"]
        subproblem_paths = regenrate_data.gen_problem_sub_problems(domain_file, curr_prob_path, curr_plan_path, sub_problems_path)
        if len(subproblem_paths) == 0:
            continue
        NProbDF = add_subproblems_to_df(NProbDF, subproblem_paths, row)

    return NProbDF
